<!DOCTYPE html><html lang="zh-CN" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="架构系列1:Qt桌面应用架构能力提升实践指南" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="前言： 对于拥有大型多人项目经验的C++桌面开发者，提升架构设计能力能让项目在可维护性、扩展性和团队协作上更上一个台阶。本指南将围绕Qt桌面应用的架构设计，系统性地介绍核心能力模型、常见架构模式、实战设计流程，以及学习资源和实践训练方法，帮助你在收到新功能需求后能够快速制定可行的架构方案。" /><meta property="og:description" content="前言： 对于拥有大型多人项目经验的C++桌面开发者，提升架构设计能力能让项目在可维护性、扩展性和团队协作上更上一个台阶。本指南将围绕Qt桌面应用的架构设计，系统性地介绍核心能力模型、常见架构模式、实战设计流程，以及学习资源和实践训练方法，帮助你在收到新功能需求后能够快速制定可行的架构方案。" /><link rel="canonical" href="https://elesos.github.io/posts/architecture-1/" /><meta property="og:url" content="https://elesos.github.io/posts/architecture-1/" /><meta property="og:site_name" content="艺搜天下—纯净互联网,让每一个页面都有价值!" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-05-01T04:30:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="架构系列1:Qt桌面应用架构能力提升实践指南" /><meta name="twitter:site" content="@xxx" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"架构系列1:Qt桌面应用架构能力提升实践指南","dateModified":"2025-05-01T04:30:00+08:00","datePublished":"2025-05-01T04:30:00+08:00","description":"前言： 对于拥有大型多人项目经验的C++桌面开发者，提升架构设计能力能让项目在可维护性、扩展性和团队协作上更上一个台阶。本指南将围绕Qt桌面应用的架构设计，系统性地介绍核心能力模型、常见架构模式、实战设计流程，以及学习资源和实践训练方法，帮助你在收到新功能需求后能够快速制定可行的架构方案。","url":"https://elesos.github.io/posts/architecture-1/","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://elesos.github.io/posts/architecture-1/"},"@context":"https://schema.org"}</script><title>架构系列1:Qt桌面应用架构能力提升实践指南 | 艺搜天下---纯净互联网,让每一个页面都有价值!</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="艺搜天下---纯净互联网,让每一个页面都有价值!"><meta name="application-name" content="艺搜天下---纯净互联网,让每一个页面都有价值!"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">艺搜天下---纯净互联网,让每一个页面都有价值!</a></div><div class="site-subtitle font-italic">知行合一 以人为镜</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/xxx" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/xxx" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hnrayer#gmail.com',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>架构系列1:Qt桌面应用架构能力提升实践指南</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>架构系列1:Qt桌面应用架构能力提升实践指南</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> xxx </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2025-05-01, 04:30 +0800" >05-01<i class="unloaded">2025-05-01T04:30:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="10253 字">56 分钟 阅读</span></div></div><div class="post-content"><p>前言： 对于拥有大型多人项目经验的C++桌面开发者，提升架构设计能力能让项目在可维护性、扩展性和团队协作上更上一个台阶。本指南将围绕Qt桌面应用的架构设计，系统性地介绍核心能力模型、常见架构模式、实战设计流程，以及学习资源和实践训练方法，帮助你在收到新功能需求后能够快速制定可行的架构方案。</p><ol><li>核心架构设计能力模型</ol><p>构建良好架构需要多方面的能力积累。以下是架构设计的核心能力要素： • 模块划分与高内聚低耦合： 学会根据功能将系统划分为清晰的模块，各模块内部保持高内聚、功能单一，对外尽量少暴露内部细节 ￼。模块之间联系应尽可能少，必要的交互要通过明确的接口进行。遵循高内聚、低耦合原则，确保模块独立性，有助于多人协作开发和后期维护 ￼ ￼。模块的大小也要适当，过大则需要进一步拆分，过小则增加管理复杂度 ￼。衡量模块独立性的标准包括耦合度（模块间互相依赖程度）和内聚性（模块内部元素联系紧密程度，理想情况下模块只做好“一件事”） ￼。 • 职责分离与设计原则： 注重单一职责原则，每个模块或类只负责特定功能，避免“大而全”导致的混乱。其它如开闭原则、里氏替换、接口隔离、依赖倒置等SOLID原则都旨在实现更灵活的架构。比如依赖倒置强调高层模块不依赖底层实现细节，双方都依赖抽象接口，从而降低耦合 ￼。遵循这些设计原则可以指导我们在架构层面实现清晰的职责划分和稳定的依赖关系 ￼。 • 依赖管理与分层： 控制模块之间的依赖方向和关系，避免环状依赖和隐式依赖。通常采用分层架构来管理依赖：高层模块依赖底层模块提供的服务，而不应反过来 ￼。典型做法是将系统分为UI层、业务逻辑层、数据访问层等，每层只与相邻层交互。这种分层架构确保了上层变化不会直接影响下层，实现稳定的演进 ￼。例如，对于Qt桌面应用，常见划分是界面层、业务层、数据层，各层职责清晰，有助于大型系统的扩展和并行开发 ￼。在C++中也可借助接口和抽象类来隔离依赖，通过依赖抽象而非实现来降低耦合度。 • 解耦手段与技术： 掌握各种解耦合的实现手段，在模块间交互时尽量避免直接耦合。Qt提供的信号与槽机制就是强大的解耦手段：对象间通过信号/槽通信，而无需直接调用彼此的方法 ￼ ￼。这种发布-订阅风格的通讯让UI和后台逻辑彼此独立，只通过信号槽联系 ￼。除了信号槽，还可以使用观察者模式、事件总线等：例如建立一个全局消息中心（事件总线），让所有模块注册其中发布/订阅消息，实现“一次广播，多处接收”，发布者和订阅者互不依赖 ￼。在复杂场景下，还可自定义QEvent配合事件循环，或采用中介者模式（如由MainWindow充当调度中心）来协调组件通信 ￼。善用这些解耦手段可以降低模块间耦合，使代码更易维护和扩展。 • 设计模式运用： 了解和掌握常用的设计模式，并知道何时应用它们，可以显著提升架构设计的质量 ￼。例如，当需要解耦多个视图与数据时，可运用MVC/MVVM模式（详见下一节）；当需要全局唯一访问点时，可谨慎使用单例模式（如Qt中的QApplication或全局配置管理）；当需要替换算法策略时，可用策略模式；需要延迟对象创建或隔离创建过程时，可用工厂模式等。设计模式提供了经过验证的通用解决方案，但关键在于恰当选型：避免生搬硬套，理解模式背后的原则（如SOLID原则）才是关键 ￼ ￼。通过模式的学习与实践，可以建立“架构思维工具箱”，在设计时快速识别可复用的设计范式，提高代码的可扩展性和可维护性 ￼。 • 架构思维与权衡取舍： 除了具体技术，还需要培养架构层面的思维习惯，例如全局观（从全局视角思考系统组件和交互）、抽象思维（抓住问题的核心抽象，忽略暂时的细节 ￼）、演进意识（考虑未来需求变化和扩展的方向）、风险评估（识别架构薄弱环节和潜在瓶颈）。架构设计充满权衡（trade-off） ￼：要在性能与可维护性、开发速度与灵活性之间取得平衡。例如，过度设计会拖慢开发、增加复杂度，而欠缺设计又会埋下维护隐患。优秀架构师会审时度势地取舍，既不过度设计也不过于短视，KISS原则（保持简单）和YAGNI原则（不要构建用不上的功能）在架构上同样适用。总结来说，核心架构能力模型包括扎实的设计原则指导、模式和手段支撑，以及面向需求变化的系统性思维。</p><ol><li>Qt桌面应用的推荐架构模式及项目结构</ol><p>Qt作为跨平台C++框架，在架构层面支持多种模式。根据项目规模和需求，可以选择合适的架构模式以提升代码组织和可维护性。以下是Qt桌面应用中常见的架构模式和典型项目结构：</p><p>2.1 MVC 与 MVVM 架构模式</p><p>MVC（Model-View-Controller）模式： MVC是一种经典的架构模式，在Qt中也被广泛采用，用于分离数据、界面和业务逻辑 ￼。 • Model（模型）： 管理应用的数据和业务逻辑，例如使用QAbstractItemModel派生类存储数据。 • View（视图）： 提供数据的可视化呈现，例如QTableView、QTreeView等Qt控件负责显示Model的数据。 • Controller（控制器）： 处理用户输入，并据此更新Model或View。在Qt中通常通过信号与槽机制扮演Controller的角色，响应用户操作信号去调用Model更新，或根据Model变化去通知View刷新 ￼。</p><p>Qt的Model/View编程体系就是MVC的体现。例如自定义数据模型继承自QAbstractListModel（Model），界面上使用QListView显示数据（View），当用户操作界面触发槽函数更新模型数据，Qt的信号/槽就起到了Controller作用 ￼ ￼。MVC优点在于清晰的职责分离，View和Model解耦合，修改界面不会影响数据处理，新增数据逻辑也不需改动UI，大大提高了可维护性和扩展性。</p><p>MVVM（Model-View-ViewModel）模式： MVVM是对MVC的改进，尤其适用于Qt Quick（QML）界面开发。在MVVM中，引入ViewModel作为中间层，专注于将Model和View绑定起来 ￼。 • Model： 数据层，提供数据内容和操作接口（例如应用的业务对象或数据源）。 • View： 表现层，通常是QML界面，负责展示数据。 • ViewModel： 桥接层，承载界面状态和逻辑，将Model的数据转换为View可用的形式，并接收View的用户操作再反馈给Model。</p><p>在Qt Quick中，QML定义界面(View)，C++对象（继承QObject并使用Q_PROPERTY等）可作为ViewModel提供属性给QML绑定，或通过信号槽响应用户交互 ￼。例如QML中的ListView绑定一个ListModel作为Model，借助一个C++ ViewModel（QObject）来处理业务逻辑和提供数据给QML属性。MVVM通过双向绑定和命令模式，减少了界面与业务代码的直接交互，使界面逻辑更简洁。Qt官方的Qt Quick模块天然支持MVVM——QML做View，QQmlContext传入的对象或QObject类型作为ViewModel，数据Model则可以是C++容器封装或QAbstractListModel子类等。MVVM的优点是进一步降低了Controller的存在感，View和Model通过ViewModel关联，便于团队并行开发：UI工程师专注于QML布局，C++工程师开发ViewModel和Model，各自职责清晰。</p><p>对比选择： 对于偏传统的Qt Widgets界面，MVC依然是实用选择；而对于Qt Quick/QML项目，MVVM更契合。两种模式目的都是关注点分离，开发者应结合项目需求选择。如果界面简单、逻辑有限，可以直接MVC或甚至简单的事件响应；但随着应用复杂度上升，提早引入MVVM能更好地管理状态和交互复杂性。此外，还可根据需要引入<strong>Presenter（MVP模式）</strong>等变体，但Qt生态中MVC/MVVM已足够覆盖多数场景。</p><p>2.2 插件化架构与模块化设计</p><p>对于大型Qt桌面应用，强烈推荐采用模块化、插件化的架构来管理复杂性。当应用规模扩张、团队多人协作时，将不同功能拆分为独立模块或插件能显著降低耦合、提高可扩展性 ￼。 • 模块化 (Modular) 架构： 利用Qt工程的.pro和.pri结构，将代码按功能分类存放在不同子目录/子项目中 ￼。每个模块可编译为静态库或动态库，在主程序中链接或加载。.pri文件可以包含模块的源代码列表和依赖设置，主工程通过include相应.pri来组装模块 ￼。这种方式实现按职责封装代码，模块内部实现细节对外部隐藏，只通过暴露的接口头文件与其他模块通信 ￼。例如，可将UI相关类集中在gui.pri，网络通信相关代码在network.pri，数据库操作在database.pri等 ￼。这样不仅代码组织清晰，也方便多人分别负责不同模块开发。此外，抽取出通用模块制成库或.pri供多个项目重用（“造轮子”），可以极大提升开发效率 ￼。 • 插件化 (Plug-in) 架构： 当项目庞大到一定程度，或需要支持可插拔的可选功能时，插件架构是理想选择 ￼。Qt本身提供了良好的插件支持（QPluginLoader等）。通常有两类插件实现方式：其一是通过动态链接库（DLL/.so）形式，主程序运行时根据需要动态加载这些库实现的功能模块；其二是使用Qt插件机制，将插件放置在约定目录，Qt在运行时扫描加载 ￼。插件需要定义统一的接口，例如定义一个抽象基类接口，主程序通过该接口与插件交互。Qt的元对象系统支持通过Q_DECLARE_INTERFACE和Q_PLUGIN_METADATA宏来标识和加载插件库。这种架构的优点是：功能模块可以独立开发、部署，必要时甚至按需加载以减少主程序体积；不同团队可以并行开发插件，主程序保持内核稳定。Qt Creator IDE本身就是插件架构的经典实例，各种工具（Qt Designer、文本编辑、调试器等）都是插件。 • 层次化与全局管理： 在模块化/插件化的同时，仍需整体架构的层次概念。常见做法是主程序作为核心层或中介层：底层是数据和基础服务模块，上层是UI和业务模块，而主程序协调各模块合作。可以设计一个中间件/管理层，处理不同模块间的调用和消息分发。例如，划分如下典型结构：UI层（界面模块）只负责显示和用户交互；通信层（网络/串口模块）封装外部通信，用单例管理网络连接 ￼；数据层（数据库模块）负责数据存储；业务逻辑层处理核心业务规则，把通信结果转发给UI；还可以有一个中间层模块专门负责连接通信模块和业务模块（作为控制/适配层） ￼。此外，一些独立公共模块如配置管理、日志、更新模块等也可以独立成插件或模块 ￼。通过这种分层+插件架构，应用各部分边界清晰：稳定的核心模块与变动的插件模块分离，降低相互影响 ￼。 • 项目结构组织： 在实际项目中，建议按照上述模块划分建立清晰的目录结构。举例来说：顶层MyApp.pro作为主工程，包含多个子项目/子目录： • core/ 核心模块（主应用，含应用初始化、主窗口，加载各插件）。 • ui/ 界面模块（UI表单、控件，遵循MVC/MVVM结构，与逻辑通过接口通信）。 • network/ 通信模块（网络或设备接口相关，封装通信细节，通过信号/槽或接口提供数据）。 • data/ 数据模块（数据库或文件读写，提供数据存取接口）。 • plugins/ 插件目录（每个子文件夹一个插件项目，可由独立pro构建为dll）。 • common/ 公共库（工具类、模型类等多个模块共享的代码，以静态库或pri形式提供）。 利用Qt的<strong>子项目（Subdirs）</strong>功能，可以把这些模块工程组合在一起，方便统一构建和管理。全局配置（如配置文件读取AppConfig）、全局事件中心（如前述的消息总线AppEvent）等可以在core模块中实现 ￼ ￼。例如，通过一个全局单例的事件中转类，让各模块不直接互调，而是通过发布事件由中转类路由，这比层层调用更清晰 ￼。总之，合理的项目结构既要方便开发，又要服务于架构的解耦目标——模块边界清晰，接口契约明确，依赖关系单向且受控 ￼。</p><p>2.3 其他架构模式提示 • 三层架构 vs. C/S架构： 桌面应用通常是本地三层（UI-逻辑-数据），但如果需要客户端/服务器（C/S）架构（例如客户端通过网络与服务器交互），也可以在架构上将前端（Qt客户端）与后端（服务器服务）当作两个独立系统设计。这种前后端分离可以通过定义清晰的通信协议（如HTTP/REST, gRPC等）实现，使桌面应用更多地关注前端展示和本地体验，而复杂业务放在服务端。这在某些企业应用中常见，但属于更大范围的架构范畴，在此不深入展开。 • 状态管理和响应式架构： 如果使用Qt Quick/QML，大型应用还需考虑状态管理架构模式，例如单向数据流（类似Flux架构）在Qt中的实践。有社区方案将Redux模式引入Qt/QML，使用一个全局Store管理状态、配合信号通知视图更新。这属于更高级的架构策略，可根据应用复杂度选用。 • 微服务架构： 微服务一般针对后端服务系统，但对于桌面应用而言，可以借鉴其思想将应用拆解为多个进程/服务，通过IPC通信，提高可靠性和解耦。Qt提供Qt Remote Objects、QLocalSocket/QTcpSocket等机制支持进程间通信。如果应用非常庞大甚至可拆成多个子应用进程运行（例如Adobe软件套件这种），可以考虑这种分布式应用架构 ￼。但一般桌面程序更多还是在单进程内通过插件模块划分来实现类似的解耦效果。</p><p>总之，Qt桌面应用的架构选择应基于需求规模和变化性。小型应用可从简单MVC开始，逐步演进；中大型应用务必模块化分层，必要时引入插件机制 ￼。良好的架构模式结合清晰的项目结构，能够支撑团队高效协作并从容应对新需求挑战。</p><ol><li>实战流程：新功能需求的架构设计步骤</ol><p>当你收到一个新的功能需求时，如何快速地将其转化为合理的架构设计方案？以下是一套实战流程，可帮助你高效完成从需求到方案文档的过程：</p><ol><li><p>需求拆解与澄清： 首先仔细阅读并理解新功能需求的描述，必要时与需求提出方（产品经理、用户）沟通澄清细节。将大需求拆解成若干子需求或用例场景，明确功能的边界和范围。分析哪些现有功能会受到影响，有无潜在冲突或兼容性要求。梳理关键业务流程和数据流：例如输入是什么，输出或结果要达到什么，以及过程中涉及哪些业务规则。只有把需求理解透彻，才能避免架构设计偏离目标。</p><li><p>识别边界与模块划分： 基于需求分析，确定该功能涉及哪些领域或模块。如果是全新功能，考虑它是否归属现有某个模块，还是需要新建模块来实现。如果现有代码中已有相关部分，评估是扩展还是重构。例如：“这个新功能主要是报表导出”，那么可能涉及UI（新增导出按钮/对话框）、业务逻辑（组织数据格式）、数据层（访问数据库或文件）。由此决定是否新建报表模块或在现有模块中扩展。划定功能边界也包括确定与其他系统或模块的接口边界。例如功能需要调用外部服务，那接口协议就是边界；或者新模块与主程序交互，通过某个抽象接口调用就是边界。边界明确后，就可以初步规划模块职责。</p><li><p>抽象接口与交互设计： 在确定模块的基础上，设计模块之间的接口契约。这是架构的关键步骤：通过定义良好的接口来隔离各部分，实现解耦合。思考每个模块向其他模块提供哪些服务、需要哪些输入输出。用UML接口图或简单列表列出接口函数/信号。例如，若新模块负责报表导出，可以定义接口IReportService，提供方法如exportReport(data, format)；UI层调用这个接口，不需要关心内部如何实现导出。接口最好基于抽象类或纯虚类定义，在C++中可用抽象基类或者通过signals/slots作为接口（比如UI发出requestExport信号，由后台槽接收处理）。同时，约定好数据交互格式，例如使用Qt的QVariant或自定义的数据结构。事件驱动的接口（如信号/槽）往往更松耦合，UI只需发信号，不需要知道谁处理 ￼。确保接口设计遵循高内聚、低耦合：每个接口尽量聚焦单一功能，不要混杂太多职责；接口参数和返回简单清晰，必要时引入数据结构来封装复杂数据，避免大量参数。这个阶段产出可以是接口定义文档或类声明草稿，便于团队讨论确认。</p><li><p>设计模块内部职责与交互： 在接口确定后，为每个模块设计其内部结构。列出模块内主要的类和职责分工。例如报表模块内部可能有ReportManager（协调导出流程）、ReportFormatter（处理格式转换）、FileWriter（输出到文件）等类。运用设计模式来安排内部结构：比如策略模式选择不同格式导出实现，模板方法模式封装导出流程等。考虑模块内部如何管理状态和与其他模块通信：是同步调用接口，还是通过异步消息。对于Qt应用，模块内部也可采用信号槽机制解耦，例如后台逻辑处理完数据后emit一个信号通知UI层刷新。 ￼建议由主窗口或核心模块充当消息调度者，各子模块彼此不直接依赖，而是通过中央调度模块连接，这样模块可以独立更换或修改而不影响其他部分。确保单一职责贯穿设计：每个类、每个函数都有明确目的。依赖方向也要规划好：遵循依赖倒置，高层（例如UI）通过接口依赖底层服务，底层模块避免反向依赖UI细节。</p><li><p>考虑扩展性和边缘情况： 对方案进行健壮性和扩展性检查。思考未来如果需求变化，这个架构能否较容易地适应？例如参数要增加、新格式支持、性能要提升等，是否有留有余量。检查解耦程度：如果某模块将来替换实现，只要符合接口即可，不应牵连大范围修改。检查依赖关系：尽量呈现树状或分层结构，而非网状交叉依赖 ￼。此外，考虑异常和边缘情况处理，比如网络失败、数据异常等模块如何配合处理。如果新功能对非功能需求（性能、内存、平台适配等）有要求，也需要在设计中有所安排（如大数据量导出要考虑分段处理、防止阻塞UI线程等等）。这一阶段常需要在几种可选方案间取舍：可以列出方案A/B比较，从复杂度、开发成本、未来维护等方面评估，选择更优的方案。同时牢记不过度设计：满足当前需求下的适度灵活即可，避免为不确定的将来增加不必要的抽象。</p><li><p>形成方案文档： 将以上设计成果整理成架构设计文档。文档应条理清晰，包括：需求简述、设计概述、模块划分图、关键接口列表、模块间交互流程（可用时序图或流程图描述关键交互）、重要类的职责说明、所用设计模式简述，以及满足需求的论证。对于Qt应用，还可附上模块依赖关系图（例如哪个模块作为插件，如何加载）、信号槽连接关系示意等。文档不需冗长，但要使读者（团队成员）清楚整个方案如何实现需求。附加说明如：为何采用某架构模式，有无替代方案及其权衡，也可以写入以供日后参考。完成初稿后，可以召集相关开发者进行评审，听取反馈并完善设计。架构设计文档既是团队沟通的依据，也是日后维护的宝贵资料。</p></ol><p>通过上述流程，从理解需求开始，逐步分解、抽象、设计，最终输出文档，你就完成了一次系统的架构设计。在这个过程中，经验发挥着重要作用：熟悉的模式会让你快速想到解决方案，了解的套路会让你少走弯路。随着不断练习，你将能更加快速地针对新需求勾勒出架构蓝图。</p><ol><li>推荐学习资料</ol><p>提升架构能力离不开持续的学习。以下书籍、博客和课程资源可帮助你深入架构设计理论和Qt/C++实践： • 《大型C++程序设计》（Large-Scale C++ Software Design，John Lakos）：经典著作，阐述了模块划分和依赖管理的方法学，是理解大型项目架构的基础读物 ￼。Lakos在更新的<strong>《大规模C++：第1卷：架构与流程》</strong>中继续深入探讨了构建可扩展C++系统的原则，特别强调了依赖方向对可维护性的影响。 • 《设计模式：可复用面向对象软件的基础》（Gang of Four Design Patterns）：面向对象设计模式的权威著作 ￼。掌握其中23种设计模式及其适用场景，将极大提升你的架构和设计技巧。这本书有中文译本，可结合实际编码体会模式的作用。 • 《架构整洁之道》（Clean Architecture，Robert C. Martin）：软件架构领域的现代经典，讲述如何构筑独立于框架、UI、数据库的“清洁”架构，提出了面向架构的SOLID原则应用。适合已有一定经验后深入理解架构本质，学习如何保持架构的灵活性和可测试性。 • 《Domain-Driven Design》（领域驱动设计，Eric Evans）：虽然偏业务建模，但其界限上下文等概念对架构划分模块很有指导意义。学会DDD能帮助你从业务角度规划系统模块，建立清晰的领域边界，对于复杂企业级应用架构尤其有用。 • 《Just Enough Software Architecture》（恰如其分的软件架构，George Fairbanks）：一本实用导向的架构书，强调如何以合适的细粒度进行架构设计，不夸大也不忽视。提供了分析质量属性、制定架构决策的指导，可帮助你掌握架构设计的平衡艺术。 • Qt/C++相关书籍与文档： 推荐 Alan Ezust 等著的<strong>“An Introduction to Design Patterns in C++ with Qt”（《Qt设计模式简介》） ￼。这本书以Qt为背景讲解设计模式，实现“Qt Way”的C++架构风格，涵盖高效代码重用和分层等内容，对Qt程序架构设计很有启发意义。此外，Mark Summerfield 的《Advanced Qt Programming》（《Qt高级编程》）深入探讨了Qt 4/5中的高级主题，包含一些架构思考。Qt官方文档和Qt Wiki上也有Best Practices</strong>章节以及Model/View编程手册，可以作为随时查阅的参考 ￼。 • 优秀博客与社区资源： 国内Qt社区有不少资深开发者分享经验。例如CSDN上飞扬青云的专栏分享了很多Qt架构和模块化经验 ￼。博客园上wzzkaifa的系列文章探讨了Qt前后端解耦的多种方式 ￼ ￼，涵盖信号槽、事件总线、MVC/MVVM等实战技巧，非常贴近Qt开发者需求。英文社区方面，Qt Blog、KDAB和ICS等公司的技术博客也经常有架构相关话题（如“大型Qt应用的架构优化”“QML架构最佳实践”等）。另外，Stack Overflow和Qt论坛有众多讨论帖，可以通过搜索具体问题（如“Qt architecture best practice”）找到他人的经验 ￼。 • 在线课程与视频： 如果喜欢系统课程，建议关注一些知名讲师的架构课程。例如Mozilla前架构师的软件架构入门课（需翻墙，Coursera等平台上有），或者国内极客时间的<strong>《软件架构设计》系列专栏。这些课程从宏观架构原理到具体案例都有涉及。针对Qt，YouTube上有Qt官方和KDAB的演讲视频</strong>（如“QML/C++ Architecture Best Practices” ￼），以及诸如C++ China社区的大会视频，搜关键词“Qt架构”可能找到一些中文演讲。通过这些多媒体资源，你可以学习到架构师们在实际项目中总结的经验和教训。 • 团队协作与Mentor： 最后不要忽视从实际工作中学习。如果身边有资深架构师或Technical Lead，请主动向他们请教设计思路。参与团队的架构评审会议，多听多问。加入一些架构师社群或读书会，与同行交流也是有效的学习途径。实践出真知，理论学习和项目历练相结合，才能真正内化为自己的架构能力。</p><p>提示： 在学习过程中，建议挑选一两个自己的或开源的Qt项目作为沙盘，边学边在其中应用新的架构思想。例如读完某章节设计模式，就思考能否改进项目中的相应部分。这种学以致用的方式效果最好。</p><ol><li>实践训练计划</ol><p>光看书不练习，架构能力难以真正提高。下面提供一个循序渐进的实践训练计划，包含具体可操作的方法，帮助你将学到的架构理念转化为实际技能： • (1) 代码重构练习： 找一段你熟悉的现有代码（最好是中等规模的Qt模块或旧项目），尝试进行架构重构。首先分析这段代码存在的架构问题，例如MainWindow过于臃肿、UI逻辑和数据耦合严重、全局变量泛滥等。然后制定重构计划，应用所学的原则拆分职责和模块。具体练习思路：将大的类拆分成更小的类，每个类各司其职；为模块引入抽象接口，替换直接依赖；把业务逻辑从UI类中提取到后台类，通过信号槽连接UI ￼；引入设计模式解决重复代码或复杂条件判断。例如，将一段硬编码的业务流程重构为状态模式或策略模式实现。重构过程中，可以对比前后架构图和代码差异，体会架构改进带来的好处（模块清晰了，依赖减小了）。这个练习可以从小范围开始（重构一个对话框模块），逐步扩展到整个子系统。通过重构，你将亲身体验如何将不良结构改造成优雅架构，这是提升架构能力的实战必经之路。 • (2) 架构方案对比练习： 针对一个简单的功能需求，分别设计两到三种不同架构方案，然后比较他们的优劣。这种练习可以选取日常生活中的小应用场景，例如“待办事项管理工具”或“文件搜索功能”等。方案A也许是单体架构（所有逻辑写在一起）；方案B采用MVC分层，方案C进一步使用插件或模块拆分。为每个方案画出模块图，写几个关键接口定义，然后从以下方面评价：代码复杂度、开发难度、未来添加新需求的方便程度、性能影响、团队协作影响等。通过对比，你会更深入地理解架构决策的取舍。例如，模块划分细致虽然初期开发稍复杂，但后期扩展容易；反之简单架构前期快，但可能很快遇到维护瓶颈 ￼。把你的对比分析写成小报告，试着向假想的团队解释你倾向哪个方案、为何。这种多方案权衡的训练，有助于培养架构决策的能力。 • (3) 独立设计一个子系统： 选择一个你感兴趣的功能，尝试从零开始进行架构设计和实现，过程完全模拟正式项目。这个子系统可以很小，例如“日志记录系统”、“插件管理器”、“模拟聊天模块”等。按照需求 -&gt; 设计 -&gt; 实现 -&gt; 测试的流程走一遍：先写下功能需求；进行模块划分（比如日志系统包含日志接口、文件输出模块、日志格式策略等）；设计接口和数据结构；然后编码实现各模块，并编写简单测试验证功能。特别强调在实现过程中遵守你设计的模块边界，通过接口交互而非破坏封装。这个练习能够锻炼你综合运用架构知识的能力，从无到有地搭建一个小型系统。完成后，对比反思哪个部分设计得好，哪个地方后来发现可以改进。必要时迭代重构，完善架构。通过动手设计实现一个完整组件，你将收获宝贵的一线经验。 • (4) 阅读并模仿优秀开源项目： 挑选一两个优秀的Qt/C++开源项目，研读它们的架构设计，并进行有针对性的模仿练习。阅读时关注项目的目录结构、模块划分、关键接口和设计模式运用。例如，研究Qt Creator、LibreOffice这些大型Qt应用如何组织上百万行代码；或者阅读一些中型开源项目（如Notepad++、qBittorrent）体会它们的分层设计。阅读时做笔记：项目如何区分核心模块和UI模块？有没有使用插件架构？接口命名和模块边界是怎样的？然后尝试将其中某些架构思想迁移到你的代码中。例如你发现某项目用消息中心解耦模块，你可以模仿实现一个简化的消息中心用于自己的项目。 ￼提供了全局消息中心的示例，你可以以此为蓝本，在练习项目中实现发布-订阅模式用于模块通信。通过读优秀代码，站在巨人肩膀上，你可以更快领悟架构技巧。同时要积极思考：若让你设计这个系统，你会如何做，有哪些不同。这种带着问题的阅读，会极大深化你的架构直觉。 • (5) 架构Kata和团队练习： 所谓“架构卡塔”（Architecture Kata）是一种练习形式：给定一个架构设计挑战，在固定时间内由个人或小组给出架构方案。你可以自己每周选择一个架构练习题，例如“设计一个在线图书馆系统的架构”或“设计一款音乐播放器应用的架构”。限制在比如1小时内，写出概要的模块图和说明，然后隔几天再回头审视，看看有无改进之处。如果有志同道合的同事或朋友，组成小组头脑风暴更佳：大家各自提出方案，互相讨论优缺点。这个过程可以模拟架构设计的思维碰撞，提高全局思考和沟通能力。另外，如果你的公司有架构评审或技术分享会议，不妨主动参加甚至主讲一次，把自己的架构方案拿出来接受反馈。这种压力测试式的练习能发现很多平时忽略的问题。在互动中，你也学会阐述架构思路，这是架构师的重要技能。 • (6) 持续的小项目实践： 除了上述专题练习，保持编码实践也很重要。尝试每隔一段时间做一个小项目（不一定都完成，重在过程），例如用Qt写一个Todo应用、记账程序或者小游戏。在每个项目中刻意应用一种新架构思路：这一项目试试MVVM加状态机，下一个项目试试插件式架构等等。在真实代码中验证学习所得，才能将概念变成熟练技巧。项目不需要大而全，小而精也行，关键是贯穿设计到实现的完整周期。随着项目实践增多，你会逐渐形成个人架构经验库，面对不同需求能迅速类比到类似的设计方案。</p><p>最后，实践训练要循序渐进且持之以恒。刚开始可能会觉得设计比实现花时间，但随着经验增长，你会越来越快地制定出合理架构。每一次练习都当作是给自己项目当架构师的机会，总结经验教训。久而久之，你在真实工作中面对新需求做架构设计时，就会游刃有余，在有限时间内拿出高质量方案。</p><p>结语： 架构能力的提升是一个长期过程，既需要理论知识的丰富，也需要大量实践磨炼。通过本指南系统学习核心架构理念、掌握Qt应用常见架构模式，并在工作和练习中不断应用、反思，你一定可以逐步成长为一名架构设计能力出众的开发者。记住，在架构世界里没有银弹，合适的就是最好的。愿你在提升架构能力的旅途中学有所成，在未来的项目中构筑出健壮优雅的Qt应用架构！祝好运！</p><p>参考资料： 1. CSDN博客：《探索QT软件开发的架构设计：从设计理念到实践应用》 ￼ ￼ 2. CSDN博客：《Qt项目架构经验总结》 ￼ ￼ 3. 博客园：wzzkaifa《Qt的前端和后端过于耦合》系列 ￼ ￼ 4. Stack Overflow：Preferred way to design application architecture in Qt ￼ 5. 《大规模C++软件设计》（John Lakos）书评摘录 ￼ 6. Qt Wiki：《An Introduction to Design Patterns in C++ with Qt》书介 ￼</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/'>架构系列</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97/" class="post-tag no-text-decoration" >架构系列</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=架构系列1:Qt桌面应用架构能力提升实践指南 - 艺搜天下---纯净互联网,让每一个页面都有价值!&url=https://elesos.github.io/posts/architecture-1/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=架构系列1:Qt桌面应用架构能力提升实践指南 - 艺搜天下---纯净互联网,让每一个页面都有价值!&u=https://elesos.github.io/posts/architecture-1/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=架构系列1:Qt桌面应用架构能力提升实践指南 - 艺搜天下---纯净互联网,让每一个页面都有价值!&url=https://elesos.github.io/posts/architecture-1/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/ai-79/">AI系列79:Kiro的 Spec 工作流</a><li><a href="/posts/game-5/">游戏系列5:Flappy Bird</a><li><a href="/posts/ai-78/">AI系列78:gpt5发布</a><li><a href="/posts/game-4/">游戏系列4:热门小游戏盘点</a><li><a href="/posts/opensource-soft-3/">开源软件推荐系列3:ohmyzsh</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/ai%E7%B3%BB%E5%88%97/">AI系列</a> <a class="post-tag" href="/tags/c-%E7%B3%BB%E5%88%97/">C++系列</a> <a class="post-tag" href="/tags/%E5%95%86%E5%93%81%E9%80%89%E8%B4%AD%E7%B3%BB%E5%88%97/">商品选购系列</a> <a class="post-tag" href="/tags/%E7%94%B5%E5%BD%B1%E7%B3%BB%E5%88%97/">电影系列</a> <a class="post-tag" href="/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E7%B3%BB%E5%88%97/">开源软件推荐系列</a> <a class="post-tag" href="/tags/qt%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/">Qt官方示例解析</a> <a class="post-tag" href="/tags/windows%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/">windows软件推荐</a> <a class="post-tag" href="/tags/linux%E5%91%BD%E4%BB%A4%E7%B3%BB%E5%88%97/">Linux命令系列</a> <a class="post-tag" href="/tags/git%E7%B3%BB%E5%88%97/">git系列</a> <a class="post-tag" href="/tags/python/">Python</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/ai-83/"><div class="card-body"> <span class="timeago small" >07-09<i class="unloaded">2025-07-09T05:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AI系列83:第三步核心模块智能识别提示词</h3><div class="text-muted small"><p> 核心模块智能识别 前置要求：请先阅读 docs/01-项目扫描报告.md 和 docs/02-项目架构文档.md，基于前两步的分析结果进行全面的模块识别。 核心目标：智能识别项目中的所有重要模块，确保识别的正确性和完整性。 第一步：项目类型确认和识别策略 1. 项目特征确认 请基于前两步分析结果确认项目特征： 项目类型：[基于架构文档确认具体类型] 架构模式：[基于架构文档...</p></div></div></a></div><div class="card"> <a href="/posts/ai-82/"><div class="card-body"> <span class="timeago small" >07-08<i class="unloaded">2025-07-08T05:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AI系列82:项目架构文档生成提示词2</h3><div class="text-muted small"><p> 项目架构文档生成 前置要求：请先阅读 docs/01-项目扫描报告.md，基于扫描结果进行深度架构分析。 请根据项目扫描结果，深度分析整个项目代码库，生成完整的架构文档。 第一轮：基础架构分析 1. 项目概览（基于扫描结果验证和补充） 项目标识：[项目名称、版本、仓库信息] 核心功能：[详细功能描述，基于代码实现验证扫描结果] 项目规模确认：[验证扫描报告中的规模评估，...</p></div></div></a></div><div class="card"> <a href="/posts/ai-81/"><div class="card-body"> <span class="timeago small" >07-07<i class="unloaded">2025-07-07T05:30:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>AI系列81:根据代码反推文档提示词1</h3><div class="text-muted small"><p> 项目扫描 请对整个项目进行全面扫描分析，按以下结构输出详细信息： 1. 项目基础信息 项目类型：[Web应用/API服务/桌面应用/移动应用/库/工具等] 主要功能：[从README、package.json等推断项目的核心功能] 项目规模：[小型&lt;1万行/中型1-10万行/大型&gt;10万行] 开发状态：[活跃开发/维护状态/遗留项目] 2. 技术栈深度分...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/flutter-1/" class="btn btn-outline-primary" prompt="上一篇"><p>Flutter系列1:flet</p></a> <a href="/posts/monkey-1/" class="btn btn-outline-primary" prompt="下一篇"><p>Tampermonkey系列1:介绍</p></a></div><div class="utterances-container"> <script src="https://utteranc.es/client.js" repo="elesos/elesos.github.io" issue-term="title" label="Comment" theme="github-dark" crossorigin="anonymous" async> </script></div><script type="text/javascript"> $(function() { window.onmessage = evt => { if (evt.origin === 'https://utteranc.es') { toggle.updateCommentStyle(); window.onmessage = null; } } }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/xxx">xxx</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/ai%E7%B3%BB%E5%88%97/">AI系列</a> <a class="post-tag" href="/tags/c-%E7%B3%BB%E5%88%97/">C++系列</a> <a class="post-tag" href="/tags/%E5%95%86%E5%93%81%E9%80%89%E8%B4%AD%E7%B3%BB%E5%88%97/">商品选购系列</a> <a class="post-tag" href="/tags/%E7%94%B5%E5%BD%B1%E7%B3%BB%E5%88%97/">电影系列</a> <a class="post-tag" href="/tags/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%E7%B3%BB%E5%88%97/">开源软件推荐系列</a> <a class="post-tag" href="/tags/qt%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E8%A7%A3%E6%9E%90/">Qt官方示例解析</a> <a class="post-tag" href="/tags/windows%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/">windows软件推荐</a> <a class="post-tag" href="/tags/linux%E5%91%BD%E4%BB%A4%E7%B3%BB%E5%88%97/">Linux命令系列</a> <a class="post-tag" href="/tags/git%E7%B3%BB%E5%88%97/">git系列</a> <a class="post-tag" href="/tags/python/">Python</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-LBHRPL0K74"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-LBHRPL0K74'); }); </script>
